we have to createsuperuser

it asks some user permission to perform the applications
 we have three users superuser,stafguser,user

 superusr -- topleveluser --every permission
 staffuser--acess django admin interface --default
 user--notauthorize to use admin site


 using this we can do crud operation and also register models as well,also permission

 create user:

 shell

 from django.contrib.auth.models import User
 usr = User.objects.create_user('Harihta','yerukondu@gmail.com','hairhta@23')

create staff user
usr.is_staff=True
usr.save()


Permissions:

myapp.add_mymodel
myapp.delete_mymodel
myapp.change_mymodel
myapp.view_mymodel

A superuser is a top-level user or administrator of the system and possesses permission to add, change, or delete other users,
as well as perform operations on all the data in the project.

The Django Admin interface makes it possible to grant and enforce permissions to access the model data. By default, 
all users get the Add, Change, View and Delete permissions on all models.

Model Permissions in Admin Interface

Letâ€™s assume that there is a Product model in a Django app named myapp. Here, a custom permission called change_category has been defined.
class Product(models.Model): 
    ProductID: models.IntegerField() 
    name : models.TextField() 
    category : models.TextField 
    class Meta: 
        permissions = [('can_change_category', 'Can change category')] 


Enforcing permissions at the view level

from django.http import HttpResponse 
from django.contrib.auth.decorators import login_required 
 @login_required 
def myview(request): 
    return HttpResponse("Hello World") 


def testpermission(user): 
    if user.is_authenticated() and user.has_perm("myapp.change_category"): 
        return True 
    else: 
        return False 


from django.contrib.auth.decorators import user_passes_test 

@user_passes_test(testpermission) 
def change_ctg(request): 
    # Logic for making change to category of product model instance            



from django.contrib.auth.decorators import permission_required 

@permission_required("myapp.change_category") 
def store_creator(request): 
    # Logic for making change to category of product model instance        


Enforcing permissions in URL patterns

from django.conf.urls import url 
from django.contrib.auth.decorators import login_required, permission_required 

urlpatterns = [ 
    url(r'^users_only/', login_required(myview)), 

    url(r'^category/', permission_required('myapp.change_category', login_url='login')(myview)), 
] 



You can use Django Admin to create a new group.    



using django admin

models.py

from django.db import models

# Create your models here.
class Employee(models.Model):
    first_name = models.CharField(max_length=200)
    last_name = models.CharField(max_length=200)
    role = models.CharField(max_length=100)
    shift = models.IntegerField()

    def __str__(self):
        return self.first_name

admin.py

from django.contrib import admin
from .models import Employee

# Register your models here.
admin.site.register(Employee)


# Command to perform migrations
python3 manage.py makemigrations
python3 manage.py migrate

# Command to run server
python3 manage.py runserver

# Command to create a super user
python3 manage.py createsuperuser



Django users are assigned permissions. Over and above this, you can customize permissions for specific models, views, and templates.